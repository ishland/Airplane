From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Paul Sauve <paul@technove.co>
Date: Sat, 6 Feb 2021 17:25:49 -0600
Subject: [PATCH] m


diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index bc4fe8ee251b02548d713ab88e329a266cd7e626..95f25b50ada51d168396a5276b227a1e543b98f2 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -726,7 +726,9 @@ public class Chunk implements IChunkAccess {
             }
 
             if (!this.world.isClientSide) {
+                this.world.currentlyTickingChunk = this; // Airplane - assign currently ticking chunk
                 iblockdata1.remove(this.world, blockposition, iblockdata, flag);
+                this.world.currentlyTickingChunk = null; // Airplane - unassign currently ticking chunk
             } else if (block1 != block && block1 instanceof ITileEntity) {
                 this.world.removeTileEntity(blockposition);
             }
diff --git a/src/main/java/net/minecraft/server/FluidTypeLava.java b/src/main/java/net/minecraft/server/FluidTypeLava.java
index 29930e801cdcb97bec2fb113ec478fe9c4a63b63..e505d2f180d183eaf2e92c8c63c7052b3933bedc 100644
--- a/src/main/java/net/minecraft/server/FluidTypeLava.java
+++ b/src/main/java/net/minecraft/server/FluidTypeLava.java
@@ -38,7 +38,7 @@ public abstract class FluidTypeLava extends FluidTypeFlowing {
                     IBlockData iblockdata = world.getType(blockposition1);
 
                     if (iblockdata.isAir()) {
-                        if (this.a((IWorldReader) world, blockposition1)) {
+                        if (this.hasBurnableBlockSurrounding(world, blockposition1)) { // Airplane - use direct world
                             // CraftBukkit start - Prevent lava putting something on fire
                             if (world.getType(blockposition1).getBlock() != Blocks.FIRE) {
                                 if (org.bukkit.craftbukkit.event.CraftEventFactory.callBlockIgniteEvent(world, blockposition1, blockposition).isCancelled()) {
@@ -61,7 +61,7 @@ public abstract class FluidTypeLava extends FluidTypeFlowing {
                         return;
                     }
 
-                    if (world.isEmpty(blockposition2.up()) && this.b(world, blockposition2)) {
+                    if (world.isEmpty(blockposition2.up()) && this.isBurnableBlock(world, blockposition2)) { // Airplane - use obfhelper
                         // CraftBukkit start - Prevent lava putting something on fire
                         BlockPosition up = blockposition2.up();
                         if (world.getType(up).getBlock() != Blocks.FIRE) {
@@ -78,14 +78,15 @@ public abstract class FluidTypeLava extends FluidTypeFlowing {
         }
     }
 
-    private boolean a(IWorldReader iworldreader, BlockPosition blockposition) {
+    private boolean hasBurnableBlockSurrounding(World world, BlockPosition blockposition) { return this.a(world, blockposition); } // Airplane - OBFHELPER
+    private boolean a(World iworldreader, BlockPosition blockposition) { // Airplane - change param
         EnumDirection[] aenumdirection = EnumDirection.values();
         int i = aenumdirection.length;
 
         for (int j = 0; j < i; ++j) {
             EnumDirection enumdirection = aenumdirection[j];
 
-            if (this.b(iworldreader, blockposition.shift(enumdirection))) {
+            if (this.isBurnableBlock(iworldreader, blockposition.shift(enumdirection))) { // Airplane - use obfhelper
                 return true;
             }
         }
@@ -93,8 +94,9 @@ public abstract class FluidTypeLava extends FluidTypeFlowing {
         return false;
     }
 
-    private boolean b(IWorldReader iworldreader, BlockPosition blockposition) {
-        return blockposition.getY() >= 0 && blockposition.getY() < 256 && !iworldreader.isLoaded(blockposition) ? false : iworldreader.getType(blockposition).getMaterial().isBurnable();
+    private boolean isBurnableBlock(World world, BlockPosition blockposition) { return this.b(world, blockposition); } // Airplane - OBFHELPER
+    private boolean b(World iworldreader, BlockPosition blockposition) { // Airplane - change param to world
+        return blockposition.getY() >= 0 && blockposition.getY() < 256 && iworldreader.getCurrentlyTickingChunkIfLoaded(blockposition) == null ? false : iworldreader.getType(blockposition).getMaterial().isBurnable(); // Airplane - use currently ticking chunk
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/server/ItemStack.java b/src/main/java/net/minecraft/server/ItemStack.java
index afa1dc693bc2e2e68294a1d3dec1c078ea95b286..279a8a739c6db0288a4531a9fd8487a311a78b70 100644
--- a/src/main/java/net/minecraft/server/ItemStack.java
+++ b/src/main/java/net/minecraft/server/ItemStack.java
@@ -310,10 +310,15 @@ public final class ItemStack {
                         int updateFlag = ((CraftBlockState) blockstate).getFlag();
                         IBlockData oldBlock = ((CraftBlockState) blockstate).getHandle();
                         BlockPosition newblockposition = ((CraftBlockState) blockstate).getPosition();
-                        IBlockData block = world.getType(newblockposition);
+                        // Airplane start - look up chunk once for onPlace below
+                        Chunk chunk = world.getChunkAtWorldCoords(newblockposition);
+                        IBlockData block = chunk.getType(newblockposition);
 
                         if (!(block.getBlock() instanceof BlockTileEntity)) { // Containers get placed automatically
+                            world.currentlyTickingChunk = chunk;
                             block.getBlock().onPlace(block, world, newblockposition, oldBlock, true, itemactioncontext); // Paper - pass itemactioncontext
+                            world.currentlyTickingChunk = null;
+                            // Airplane end
                         }
 
                         world.notifyAndUpdatePhysics(newblockposition, null, oldBlock, block, world.getType(newblockposition), updateFlag, 512); // send null chunk as chunk.k() returns false by this point
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 9dc574326e22669cb69f856a64bfc12cc95ef511..b6fe0e7dea1753e0068a072aee89ed2ecb681094 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -460,6 +460,15 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
     public final Chunk getChunkIfLoaded(BlockPosition blockposition) {
         return ((WorldServer) this).getChunkProvider().getChunkAtIfLoadedImmediately(blockposition.getX() >> 4, blockposition.getZ() >> 4);
     }
+    // Airplane start - getChunkIfLoaded with currently ticking check
+    public Chunk getCurrentlyTickingChunkIfLoaded(BlockPosition blockposition) {
+        int chunkX = blockposition.getX() >> 4, chunkZ = blockposition.getZ() >> 4;
+        if (this.currentlyTickingChunk != null && chunkX == this.currentlyTickingChunk.locX && chunkZ == this.currentlyTickingChunk.locZ) {
+            return this.currentlyTickingChunk;
+        }
+        return ((WorldServer) this).getChunkProvider().getChunkAtIfLoadedImmediately(chunkX, chunkZ);
+    }
+    // Airplane end
 
     //  reduces need to do isLoaded before getType
     public final IBlockData getTypeIfLoadedAndInBounds(BlockPosition blockposition) {
@@ -729,7 +738,9 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
     public void neighborChanged(BlockPosition pos, Block blockIn, BlockPosition fromPos) { a(pos, blockIn, fromPos); } // Paper - OBFHELPER
     public void a(BlockPosition blockposition, Block block, BlockPosition blockposition1) {
         if (!this.isClientSide) {
-            IBlockData iblockdata = this.getType(blockposition);
+            // Airplane start - store chunk for physics
+            Chunk chunk = this.getChunkAtWorldCoords(blockposition);
+            IBlockData iblockdata = chunk.getType(blockposition);
 
             try {
                 // CraftBukkit start
@@ -743,7 +754,9 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
                     }
                 }
                 // CraftBukkit end
+                this.currentlyTickingChunk = chunk;
                 iblockdata.doPhysics(this, blockposition, block, blockposition1, false);
+                this.currentlyTickingChunk = null;
             // Spigot Start
             } catch (StackOverflowError ex) {
                 lastPhysicsProblem = new BlockPosition(blockposition);
@@ -787,6 +800,8 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
         return this.getChunkProvider().getLightEngine();
     }
 
+    protected Chunk currentlyTickingChunk; // Airplane - the chunk being ticked
+
     @Override
     public IBlockData getType(BlockPosition blockposition) {
         // CraftBukkit start - tree generation
@@ -800,7 +815,15 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
         if (isOutsideWorld(blockposition)) {
             return Blocks.VOID_AIR.getBlockData();
         } else {
-            Chunk chunk = (Chunk) this.getChunkProvider().getChunkAt(blockposition.getX() >> 4, blockposition.getZ() >> 4, ChunkStatus.FULL, true); // Paper - manually inline to reduce hops and avoid unnecessary null check to reduce total byte code size, this should never return null and if it does we will see it the next line but the real stack trace will matter in the chunk engine
+            // Airplane start
+            int chunkX = blockposition.getX() >> 4, chunkZ = blockposition.getZ() >> 4;
+            Chunk chunk;
+            if (this.currentlyTickingChunk != null && this.currentlyTickingChunk.locX == chunkX && this.currentlyTickingChunk.locZ == chunkZ) {
+                chunk = this.currentlyTickingChunk;
+            } else {
+                chunk = (Chunk) this.getChunkProvider().getChunkAt(chunkX, chunkZ, ChunkStatus.FULL, true); // Paper - manually inline to reduce hops and avoid unnecessary null check to reduce total byte code size, this should never return null and if it does we will see it the next line but the real stack trace will matter in the chunk engine
+            }
+            // Airplane end
 
             return chunk.getType(blockposition);
         }
@@ -811,7 +834,15 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
         if (isOutsideWorld(blockposition)) {
             return FluidTypes.EMPTY.h();
         } else {
-            Chunk chunk = this.getChunkAtWorldCoords(blockposition);
+            // Airplane start
+            int chunkX = blockposition.getX() >> 4, chunkZ = blockposition.getZ() >> 4;
+            Chunk chunk;
+            if (this.currentlyTickingChunk != null && this.currentlyTickingChunk.locX == chunkX && this.currentlyTickingChunk.locZ == chunkZ) {
+                chunk = this.currentlyTickingChunk;
+            } else {
+                chunk = this.getChunkAt(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+            }
+            // Airplane end
 
             return chunk.getFluid(blockposition);
         }
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index c43df937a985626f0d9cc5a89e9c22646b33ade0..938f9e36ef1328d0a4a368764d62e0e1daad6f54 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -1050,6 +1050,7 @@ public class WorldServer extends World implements GeneratorAccessSeed {
         // Paper start - optimise random block ticking
         gameprofilerfiller.exit();
         if (i > 0) {
+            this.currentlyTickingChunk = chunk; // Airplane - assign currently ticking chunk
             gameprofilerfiller.enter("randomTick");
             timings.chunkTicksBlocks.startTiming(); // Paper
 
@@ -1085,6 +1086,7 @@ public class WorldServer extends World implements GeneratorAccessSeed {
                     // TODO CHECK ON UPDATE
                 }
             }
+            this.currentlyTickingChunk = null; // Airplane - unassign currently ticking chunk
             gameprofilerfiller.exit();
             timings.chunkTicksBlocks.stopTiming(); // Paper
             // Airplane start
@@ -1178,12 +1180,16 @@ public class WorldServer extends World implements GeneratorAccessSeed {
     }
 
     private void b(NextTickListEntry<Block> nextticklistentry) {
-        IBlockData iblockdata = this.getType(nextticklistentry.a);
+        // Airplane start - store looked up chunk
+        Chunk chunk = this.getChunkAtWorldCoords(nextticklistentry.a);
+        IBlockData iblockdata = chunk.getType(nextticklistentry.a);
 
         if (iblockdata.a((Block) nextticklistentry.b())) {
+            this.currentlyTickingChunk = chunk;
             iblockdata.a(this, nextticklistentry.a, this.random);
+            this.currentlyTickingChunk = null;
+            // Airplane end
         }
-
     }
 
     // Tuinity start - log detailed entity tick information
